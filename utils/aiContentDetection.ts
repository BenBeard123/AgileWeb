/**
 * V2: AI-generated content detection
 * Detects patterns that suggest AI-generated content
 */

export interface AIContentAnalysis {
  detected: boolean;
  confidence: number;
  indicators: string[];
}

/**
 * Detects AI-generated content patterns
 */
export function detectAIContent(
  text: string,
  metadata?: { title?: string; description?: string }
): AIContentAnalysis {
  if (!text || typeof text !== 'string') text = '';

  const fullText = (
    text + ' ' +
    (metadata?.title || '') + ' ' +
    (metadata?.description || '')
  ).toLowerCase();

  const indicators: string[] = [];

  // AI generation markers
  const aiMarkers = [
    'generated by',
    'created by ai',
    'ai-generated',
    'chatgpt',
    'gpt-',
    'claude',
    'midjourney',
    'dall-e',
    'stable diffusion',
    'ai created',
    'machine generated',
  ];

  // Check for AI markers
  aiMarkers.forEach(marker => {
    if (fullText.includes(marker)) {
      indicators.push('ai_marker');
    }
  });

  // Check for suspiciously perfect formatting
  if (text.split('\n').length > 10 && text.length > 500) {
    // Very structured, long content might be AI
    const sentenceLengths = text.split(/[.!?]/).map(s => s.trim().length);
    const avgLength = sentenceLengths.reduce((a, b) => a + b, 0) / sentenceLengths.length;
    if (avgLength > 80 && sentenceLengths.length > 5) {
      // Very uniform sentence lengths
      indicators.push('uniform_structure');
    }
  }

  // Check for common AI phrases
  const aiPhrases = [
    'as an ai',
    'i am an ai',
    'i cannot',
    'i don\'t have',
    'i\'m not able to',
    'i apologize, but',
  ];

  aiPhrases.forEach(phrase => {
    if (fullText.includes(phrase)) {
      indicators.push('ai_phrase');
    }
  });

  // Metadata indicators
  if (metadata) {
    if (metadata.title?.toLowerCase().includes('ai generated')) {
      indicators.push('metadata_marker');
    }
    if (metadata.description?.toLowerCase().includes('ai')) {
      indicators.push('metadata_marker');
    }
  }

  const detected = indicators.length > 0;
  const confidence = Math.min(0.9, 0.3 + (indicators.length * 0.15));

  return {
    detected,
    confidence,
    indicators: [...new Set(indicators)],
  };
}

